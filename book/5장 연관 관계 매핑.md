#### 연관 관계 매핑

🎯 학습목표

1. 연관 관계 매핑의 종류와 엔티티 연관 관계 매핑을 설정하는 방법 학습
2. 매핑된 엔티티 조회 시 즉시 로딩과 지연 로딩의 차이점 이해

<details>
<summary>✍️ 연관 관계 매핑 종류</summary>
<br>

엔티티들은 대부분 다른 엔티티와 연관 관계를 맺고 있다.

엔티티에 연관 관계를 매핑해두고 필요할 때 연관된 엔티티를 사용하여 좀 더 객체지향적으로 프로그래밍할 수 있다.

- 연관 관계 매핑의 종류
    - 일대일: @OneToOne
    - 일대다: @OneToMany
    - 다대일: @ManyToOne
    - 다대다: @ManyToMany

- 연관 관계 매핑의 방향성
    - 단방향
    - 양방향

✔️ 일대일 단방향 매핑하기

|cart|
|---|
|cart_id (PK)|
|member_id (FK)|

|member|
|---|
|member_id (PK)|
|name|
|email|
|password|
|address|
|role|

장바구니와 회원은 일대일로 매핑돼 있으며, 장바구니 엔티티가 회원 엔티티를 참조하는 일대일 단방향 매핑이다.

엔티티를 조회할 때 연관된 엔티티도 한 번에 조회하는 것을 즉시 로딩이라고 하는데 일대일, 다대일로 매핑할 경우 즉시 로딩을 기본 Fetch 전략으로 설정한다.

✔️ 다대일 단방향 매핑하기

하나의 장바구니에는 여러 개의 상품들이 들어갈 수 있다.

또한, 같은 상품을 여러 개 주문할 수도 있으므로 몇 개를 담아 줄 것인지도 설정해야 한다.

|cart|
|---|
|cart_id (PK)|
|member_id (FK)|

|cart_item|
|---|
|cart_item_id (PK)|
|cart_id (FK)|
|item_id (FK)|
|count|

|item|
|---|
|item_id (PK)|
|item_nm|
|price|
|stock_number|
|item_detail|
|item_sell_status|

✔️ 다대일/일대다 양방향 매핑하기

양방향 매핑이란 단방향 매핑이 2개 있다고 생각하면 된다.

|member|
|---|
|member_id (PK)|
|name|
|email|
|password|
|address|
|role|

|orders|
|---|
|order_id (PK)|
|member_id (FK)|
|order_date|
|order_status|

|order_item|
|---|
|order_item_id (PK)|
|order_id (FK)|
|item_id (FK)|
|order_price|
|count|

양방향 매핑에서는 '연관 관계 주인'을 설정해야 한다는 점이 중요하다.

ORDERS와 ORDER_ITEM 테이블을 ORDER_ID를 외래키로 조인하면 주문에 속한 상품들을 알 수 있고 주문 상품은 어떤 주문에 속하는지 알 수 있다. 즉, 테이블은 외래키 하나로 양방향 조회가 가능하다.

엔티티는 테이블과 다른데 양방향 연관 관계에서 객체의 참조는 둘인데 외래키는 하나이므로 둘 중 누가 외래키를 관리할지를 정해야 한다.

- 연관 관계의 주인은 외래키가 있는 곳으로 설정
- 연관 관계의 주인이 외래키를 관리(등록, 수정, 삭제)
- 주인이 아닌 쪽은 연관 관계 매핑시 mappedBy 속성의 값으로 연관 관계의 주인을 설정
- 주인이 아닌 쪽은 일기만 가능

✔️ 다대다 매핑하기

관계형 데이터베이스는 정규화된 테이블 2개로 다대다를 표현할 수 없고 연결 테이블을 생성해서 일대다, 다대일 관계로 풀어낸다.

다대다 매핑을 사용하지 않는 이유는 연결 테이블에는 컬럼을 추가할 수 없기 때문이다.

연결 테이블에는 조인 컬럼뿐 아니라 추가 컬럼들이 필요한 경우가 많고 엔티티를 조회할 때 중간 테이블이 있기 때문에 어떤 쿼리문이 실행될지 예측하기 어렵다.

</details>

<details>
<summary>✍️ 영속성 전이</summary>
<br>

✔️ 영속성 전이란?

엔티티의 상태를 변경할 때 해당 엔티티와 연관된 엔티티의 상태 변화를 전파시키는 옵션이다. 이때 부모는 One에 해당하고 자식은 Many에 해당한다.

영속성 전이 옵션은 단일 엔티티에 완전히 종속적이고 부모 엔티티와 자식 엔티티의 라이프 사이클이 유사할 때 활용하는 것을 추천한다.

|CASCADE|설명|
|---|---|
|PERSIST|부모 엔티티가 영속화될 때 자식 엔티티도 영속화|
|MERGE|부모 엔티티가 병합될 때 자식 엔티티도 병합|
|REMOVE|부모 엔티티가 삭제될 때 연관된 자식 엔티티도 삭제|
|REFRESH|부모 엔티티가 refresh되면 연관된 자식 엔티티도 refresh|
|DETACH|부모 엔티티가 detach되면 연관된 자식 엔티티도 detach|
|ALL|부모 엔티티의 영속성 상태 변화를 자식 엔티티에 모두 전이|

✔️ 고아 객체 제거하기

부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 고아 객체라고 한다.

고아 객체 제거 기능을 사용하기 위해서는 참조하는 곳이 하나일 때만 사용해야 한다.

@OneToOne, @OneToMany 어노테이션에서 옵션으로 사용하는데 orphanRemoval = true를 추가하면 된다.

</details>

<details>
<summary>✍️ 지연 로딩</summary>
<br>

일대일, 다대일로 매핑할 경우 기본 전략인 즉시 로딩을 통해 엔티티를 함께 가지고 온다.

작성하고 있는 비즈니스 로직에서 사용하지 않을 데이터도 한꺼번에 들고 오는데 쿼리가 어떻게 실행될지 예측할 수 없고 성능 문제도 있을 수 있다.

지연 로딩으로 설정하면 실제 엔티티 대신에 프록시 객체를 사용하는데 프록시 객체는 사용되기 전까지 데이터 로딩을 하지 않고 실제 사용 시점에 조회 쿼리문이 실행된다.

</details>

<details>
<summary>✍️ Auditing을 이용한 엔티티 공통 속성 공통화</summary>
<br>

Spring Data Jpa에서는 Auditing 기능을 제공하여 엔티티가 저장 또는 수정될 때 자동으로 등록일, 수정일, 등록자, 수정자를 입력해준다.

이런 공통 멤버 변수들을 추상 클래스로 만들고 해당 추상 클래스를 상속받는 형태로 엔티티를 리팩토링 한다.

</details>
